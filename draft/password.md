---
title: 关于| 密码学
date: 2023-5-11
categories: 
  - 知识科普
tags: 
  - 博客
---

:::tip 前言



:::

## 密码简介



# 数据安全

对数据安全的处理主要分为：

- 摘要算法，不属于加解密算法，对一份数据内容生成一个唯一不变的 hash 值，只要内容不变，生成的 hash 值就不会变。整个过程不可逆。
- 加密算法，可以对原始数据内容加密，之后还可以进行解密获得原始内容的算法。其又分为对称加密和非对称加密。

## 摘要算法

消息摘要算法的主要特征是加密过程不需要密钥，并且经过加密的数据无法被解密，可以被解密逆向的只有CRC32算法，只有输入相同的明文数据经过相同的消息摘要算法才能得到相同的密文。

一些使用场景：

- 将明文密码通过摘要算法生成散列值后，再存入数据库
- 文件断点续传与秒传，用摘要确定文件的唯一性
- 数字签名

摘要算法的特点：

- 无论输入的消息有多长，计算出来的消息摘要的长度总是固定的。
- 消息摘要看起来是“随机的”，但并不是真正随机的，因为用相同的算法对相同的消息求两次摘要，其结果必然相同；而若是真正随机的，则无论如何都是无法重现的。因此消息摘要是“伪随机的”。
- 只要输入的消息不同，对其进行摘要以后产生的摘要消息也必不相同。
- 消息摘要函数是无陷门的单向函数，即只能进行正向的信息摘要，而无法从摘要中恢复出任何的消息，甚至根本就找不到任何与原信息相关的信息。
- 好的摘要算法，没有人能从中找到“碰撞”，虽然“碰撞”是肯定存在的。即对于给定的一个摘要，不可能找到一条信息使其摘要正好是给定的。或者说，无法找到两条消息，使它们的摘要相同。

常见摘要算法有： MD5, SHA1, SHA224, SHA256, SHA3, SHA384, SHA512

比如，以下是这些摘要算法对字符串 `'helloworld'` 执行后的结果

| 算法     | Bit  | 长度 | 结果(十六进制字符串)                                         |
| :------- | :--- | :--- | :----------------------------------------------------------- |
| `MD5`    | 128  | 32   | fc5e038d38a57032085441e7fe7010b0                             |
| `SHA1`   | 160  | 40   | 6adfb183a4a2c94a2f92dab5ade762a47889a5a1                     |
| `SHA224` | 244  | 56   | b033d770602994efa135c5248af300d81567ad5b59cec4bccbf15bcc     |
| `SHA256` | 256  | 64   | 936a185caaa266bb9cbe981e9e05cb78cd732b0b3280eb944412bb6f8f8f07af |
| `SHA3`   | 512  | 128  | 9f65a7b5b085f6e92901a491e4dec19fcb89331b67db3b86c472aae049d8ef6141f79895d1cbef19ee529ca37c97843ca4deb3351d8ff9e182bc004097deca98 |
| `SHA384` | 384  | 96   | 97982a5b1414b9078103a1c008c4e3526c27b41cdbcf80790560a40f2a9bf2ed4427ab1428789915ed4b3dc07c454bd9 |
| `SHA512` | 512  | 128  | 1594244d52f2d8c12b142bb61f47bc2eaf503d6d9ca8480cae9fcf112f66e4967dc5e8fa98285e36db8af1b8ffa8b84cb15e0fbcf836c3deb803c13f37659a60 |

## 加密算法

加密算法，是可以对原始数据内容加密，之后还可以进行解密获得原始内容的算法。

加密算法又分为：

- 对称加密，加密和解密都使用同一个密钥，通常称之为 Session Key 。
- 非对称加密，加密和解密所使用的不是同一个密钥，通常有两个密钥，称为公钥(Public Key)和私钥(Private Key)，通常，公钥可公开，用于加密，私钥不应公开，用于解密。

### 对称加密

对称加密，加密和解密都使用同一个密钥。

缺点是密钥暴露后，获得密钥的人都可以进行解密，比如服务端和客服端如果要使用对称加密，服务端需要将密钥传递给客户端，如果被其他人获取到密钥，那加密的内容就没有意义了。

常用的对称加密算法有： AES、DES、Triple DES、Rabbit、RC4、RC4Drop 等。

现在普遍使用的是 AES 算法。

### 非对称加密

一些使用场景：

- 数字签名和数字证书
- 比特币交易

加密和解密所使用的不是同一个密钥，通常有两个密钥，称为“公钥”和“私钥”，用公钥可以解开私钥加密的信息，反之亦成立。通常，公钥可公开，用于加密，私钥不应公开，用于解密。

这样，服务端只需要将公钥告知客户端，客户端使用公钥将数据加密后，传输给服务端，服务端使用自己手上的私钥将内容解密出来即可。

常用的非对称加密算法有：RSA、EIGamal、DSA 等。

目前普遍使用的是 RSA 算法。

## 数字签名

- [数字签名是什么？(阮一峰)(opens new window)](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)

数字签名是非对称密钥加密技术与数字摘要技术的应用。

数字签名是只有信息的发送者才能产生的，别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。一套数字签名通常定义两种互补的运算，一个用于签名，另一个用于验证。

比如，服务端想要发送一份数据给客户端，为了防止数据不被冲突截获修改，服务端对这份数据进行摘要算法，获取一个 hash 值，然后再用服务端的私钥对这个 hash 值进行加密，这样生成的就是数字签名，将数字签名随着数据一起发送给客户端。

客户端收到了数据和数字签名，然后用手上的公钥将数字签名解密，获取到服务端发送的真实 hash 值，再使用摘要算法获取数据的 hash 值，将自己获取的 hash 值和服务端发送的 hash 值作对比，如果一致，则证明数据没有被修改过，是服务端发送的原始数据，可以放心使用，如果不一致，则说明数据被修改过了。

但又有一个问题，如果一开始服务端传递公钥给客户端时，被破坏者截获，破坏者保存了服务端的公钥，而将自己的公钥发给了客户端，客户端不知道这个是破坏者的公钥，还以为就是服务端的公钥，然后，客户端使用公钥加密数据并发送，破坏者截获到，用自己的私钥解密即可获取数据，破坏者修改一些数据后，然后再用自己之前截获到的服务端公钥进行加密传给服务端，服务端拿到数据后用私钥可以解密数据，则以为这就是客户端发来的数据，这样，服务端和客户端根本不知道他们的数据已经被破坏者截获和修改了。

为了解决这个问题，就用到了数字证书这个办法。

## 数字证书

数字证书是由权威机构颁发的，用于证明数据就是原始数据。

这个权威机构就叫做"证书中心"（Certificate Authority，简称CA），那 CA 是如何确保数据的真实性呢？

CA 也有自己的公钥和私钥， 公钥是网上公开的，私钥只有 CA 自己持有，CA 用自己的私钥，对服务端想要发送给客户端的公钥和一些相关信息一起加密，生成一份 "数字证书"（Digital Certificate），这个数字证书只能使用 CA 的公钥才能打开查看详情。

客户端（浏览器）有一个"证书管理器"，这个证书管理器中，有"受信任的根证书颁发机构"列表。这个列表中保存这这些权威 CA 的公钥，客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。

服务端拿到这个数字证书后，在每次发送数据给客户端时，将数字签名和数字证书也一起发送给客户端，客户端拿到数据、数字签名、数字证书后，首先对数字证书进行验证：

- 验证收到的数字证书是否是客户端已知的权威 CA 所颁发的；
- 验证证书的有效期是否过期；
- 验证证书记录的网站是否是当前正在浏览器的网站；

以上几个验证，如果有任何一个验证不通过，客户端都会发出警告。

如果验证全部通过，说明数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器通信。



# 密码学

## 对称加密

### 对称加密原理

- 要素

  - 明文

  - 加密算法

  - 秘钥

  - 密文

  - 解密算法

- 密码分析

  - 唯密文

    - 密文

  - 已知明文

    - 密文

    - 秘钥产生的明文-密文对

  - 选择明文

    - 密文

    - 选定的明文信息，以及使用秘钥产生的密文

  - 选择密文

    - 密文

    - 选定的密文信息，以及使用秘钥产生的解密明文

  - 选择文本

    - 密文

    - 选定的明文信息，以及使用秘钥产生的密文

    - 选定的密文信息，以及使用秘钥产生的解密明文

- Feistel密码结构

  - 对称分组加密算法

    - 2w长度的明文信息，每一轮次均执行LEi xor F(REi, ki)作为下一轮的RE，本轮RE成为下一轮LE

    - 分组大小、秘钥大小、迭代轮数、子秘钥产生算法、轮函数

### 对称分组加密算法

- 分组密码处理固定大小的明文输入分组，对每个明文分组产生同等大小的密文分组

- DES

  - 明文长度64比特，秘钥长度56比特

- 3DES

  - 加密三次使用DES算法，加密-解密-加密过程使用不同秘钥

  - C=E(K3, D(K2, E(K1, P)))

- AES

  - 分组大小128bit，秘钥长度128、192、256bit

  - 不是典型的feistel结构，每次轮换和移位时都并行处理整个数据分组

  - 秘钥扩展为44个32bit字的数组，每四个字作为一轮的轮秘钥

  - 四个变化函数

    - 字节替换

      - 用S盒对分组逐一的字节替换

    - 行移位

      - 列简单移位

    - 列混合

      - 对列的每个字节替换，是一个与本列全部字节相关的函数

    - 轮秘钥加

      - 当前分组异或一部分扩展秘钥

### 随机数和伪随机数

- 特性

  - 随机性、不可预测性

- 真随机数发生器

- 伪随机数发生器

- 伪随机函数

### 流密码和RC4

- 使用伪随机字节产生器（密钥流产生器）把秘钥转化为秘钥流，异或明文流产生密文流

- RC4

  - 子主题 1

### 分组密码工作模式

- 电子密码本模式

  - 一次处理固定量比特，明文每个分组都使用同一秘钥加密

- 密码分组链接模式

  - 当前轮次的输入为前一次密文和当前明文的异或，再使用同一秘钥加密

- 密码反馈模式

  - 加密模块的输入是一个64位的移位寄存器，初始化为IV。经加密后，取密文最高开始的s位异或明文s位为c并传输。之后寄存器左移s位，空出的位置填入c，重复过程直到全部明文被加密发送

- 计数器模式

## 公钥密码和消息认证

### 消息认证方法

- 消息认证

  - 验证信息有无被篡改

  - 来源是否可信

  - 信息时效性

- 非加密的消息认证

  - 消息认证码

    - 将秘钥连同消息进行计算，生成消息认证码，一并发送。接收方用相同的秘钥计算认证码

    - 可以做到：1、辨别是否被篡改；2、确定消息来源是否是授权；3、如果有序列号，则可以确定正确序列

  - 单项散列函数

    - 利用单项散列函数，计算变长消息的固定长度摘要，经处理后随消息一同发送

      - 使用传统加密方式加密消息摘要

        - 通信双方使用同一秘钥，加密的消息摘要在bob被解码，同bob自己计算出的消息摘要对比

      - 使用公钥加密信息摘要

        - alice用其公钥加密消息摘要，bob接受后使用alice的秘钥解密，并与自己计算的摘要对比

      - 使用秘密值

        - Alice&Bob共享一个秘密值S，计算摘要时连同S一起计算；消息连同摘要一起发送，Bob接受后，加上S计算摘要并对比

### 安全散列函数

- 性质

  - 适用于生成任意长度的数据块

  - 生成固定长度的输出

  - 知道x，正向计算H(x)容易

  - 知道H(x)，反向计算x在计算上不可行

    - 单向性、抗原像攻击性

  - f=H(x)是一一映射的函数，一个特定的x有且仅有一个H(x)

    - 抗第二原像攻击性

  - 知道H(x)，暴力碰撞出y，使得H(x)=H(y)在计算上是不可能的

    - 抗碰撞性

- SHA安全散列函数

  - 追加填充比特

  - 追加长度

  - 初始化散列缓冲区

  - 处理1024bit数据块消息

### 消息认证码

- HMAC

- 基于分组密码的MAC

### 公钥密码原理

- 要素

  - 明文

  - 加密算法

  - 公钥和私钥

  - 密文

  - 解密算法

- 分类

  - 加解密

    - 发送者用接受者的公钥加密信息

  - 数字签名

    - 发送者使用自己的秘钥签名信息

  - 密钥交换

    - 通信双方交换会话密钥

- 要求

  - Bob计算密钥对较为容易

  - 已知Bob的公钥和消息时，Alice容易计算密文

  - Bob容易通过私钥解密密文

  - 通过公钥不可能计算私钥

  - 知道密文和公钥不可能恢复明文

### 公钥密码算法

- RSA

  - 要素

    - 模值n

    - 互质大素数p、q

  - 运算

    - 生成公钥{e,n}

      - 选择e，使得e与(p-1)(q-1)互质且小于

    - 生成私钥{d,n}

      - 解方程 ed mod (p-1)(q-1) = 1

    - 加密

      - C=M^e mod n

      - n = pq

    - 解密

      - M = C^d mod n

- D-H密钥交换

  - 基于离散对数的计算困难性

  - 仅使用密钥交换协议，不能抵抗中间人攻击

- 数字签名标准

- 椭圆曲线算法

### 数字签名

- 保证了消息源和数据完整性

- 对消息全体使用散列码，生成认证符，再对认证符签名，就不用对全部消息加密，节省了开支



## 参考


索引 B+tree



主键索引（一次就可以查询出结果）

二级索引（第一次查询主键，根据主键查询出结果【回表操作】；如果第一次查询字段存在索引中就叫覆盖索引）



物理存储角度

主键索引（聚簇索引）。二级索引（辅助索引）



字段特性

主键索引。唯一索引（唯一特性）。普通索引（没有唯一性）。前缀索引（字符型的前几个字符）



字段个数

单列索引。联合索引（几个字段）



联合索引（最左匹配原则，先按照最左排序，最左匹配，依次向左匹配）



联合索引范围查询，遇到范围查询就会停止匹配，范围匹配可以用到联合索引，后面不行

遇到【<,>,%x,%x%】会停止

【<=,>=,BETWEEN,x%】不停止



索引下推

减少回表操作，在索引层过滤出符合的记录



啥时候创建

字段有唯一性

用于where查询字段

用于group by和order by的字段



啥时候不用

除去where。group by和order by的字段

字段中有大量重复数据

表数据太少

经常更新



优化索引的方法

- 使用前缀索引优化
- 覆盖索引优化（可以通过建立联合索引查询，避免回表）
- 主键最好自增（因为主键索引的B+tree是排序的）
- 索引最好设置为NOT NULL（NULL会加大索引查询的复杂性，还占用空间）



索引失效

- 左或左右模糊匹配
- 对索引列计算。函数。类型转换等操作
- 联合索引不遵循最左匹配原则
- 在where中，在or前的是索引列，在or后不是索引列就会失效



参考指标

- 避免`Using filesort`,文件排序
- 避免`Using temporary`,临时表
- 使用`Using index`,索引





事务

原子性，隔离性。持久性。一致性

- 持久性是通过 redo log （重做日志）来保证的；
- 持久性是通过 redo log （重做日志）来保证的；
- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
- 一致性则是通过持久性+原子性+隔离性来保证；



并发事务的问题

- 脏读（如果一个事务「读到」了另一个「未提交事务修改过的数据）
- 不可重复读（在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况）
- 幻读（在一个事务内多次查询某个符合查询条件的「记录数量」，如果出现前后两次查询到的记录数量不一样的情况）



事务的隔离级别

- 读未提交RU（什么都不避免）
- 读提交RC（避免脏读）【read view实现，每个语句执行前快照】
- 可重复读RR（避免脏读，不可重复读，一定程度避免幻读）【启动事务时快照】
- 串行化（影响性能）（避免脏读，不可重复度，幻读）【加读写锁实现】



可重复读两种避免幻读

快照读（MVCC解决，普通查询）

当前读（next-key[记录锁+间隙锁]，select···for update）



Read View

- creator_trx_id：创建RV事务的事务id
- m_ids：活跃且未提交的事务id列表
- min_trx_id：m_ids中最小事务的事务id
- max_trx_id：最新事务id+1

聚簇索引两个隐藏列

- trx_id（事务对记录改动时写入事务id）
- roll_pointer（改动时将旧版写入undo日志，再链接指向旧版）



mysql的锁

- 全局锁（在不支持事务的全库逻辑备份）



表级锁

- 表锁【共享锁（读锁），独占锁（写锁）】
- 元数据锁（MDL）【CRUD 操作时，加的是 MDL 读锁，表做结构变更操作的时候，加的是 MDL 写锁，非显性】
- 意向锁（快速判断表中记录是否被加锁）【在加表锁之前】
- AUTO-INC 锁【实现主键自增】

行级锁

- 记录所（锁一条记录）【分x和s锁】
- 间隙锁（锁一个范围，不包括记录）
- Next-key Lock（记录锁+间隙锁）





mysql日志

- undo 日志（Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**）

- redo 日志（ Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要**用于掉电等故障恢复**）
- binlog 日志（Server 层生成的日志，主要**用于数据备份和主从复制**）



Buffer Pool【缓存「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等等。】



WAL 技术：Mysql的写操作并不是立刻写道磁盘上，而是先写日志，然后再在合适的时间写在磁盘上

由后台线程将缓存在bufferpool的脏页刷新到磁盘上



redo 【物理日志，描述对数据页的修改，对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新】

让MySQL由crash-safe的能力

将写操作从随机写变成了顺序写



redo 日志记录了事务修改后的数据状态，是更新之后的值，主要用于事务的奔溃恢复，保证事务的持久性

redo log buffer啥时候刷盘

- mysql正常关闭
- redo log buffer占用过半
- innoDB的后台线程每隔一秒
- 使用参数，每次事务提交持久化



undo 记录事务的修改前的状态，是更新之前的值，主要用于事务回滚，保证事务的原子性

重做日志文件组

是以**循环写**的方式工作的

有容量上限



binlog是追加写，写满一个文件后，创建新文件，是全量日志

- 主从复制
- 数据备份

主从复制（异步过程）

写入binlog ，通过log dump线程发送binlog日志，从库创建io线程写入relay log，sql线程再读取relay log写入数据库，回放binlog





两提交阶段（懒得写了）

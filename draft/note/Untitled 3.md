### 悲观锁

悲观锁认为线程安全问题一定会发生，因此在操作数据库之前需要先获取锁，确保线程串行执行。常见的悲观锁有 `synchronized` 和 `lock`。

优点

- 确保线程安全，避免数据不一致。

缺点

- 性能较低，因为需要加锁和释放锁，限制了并发度。
- 并发度低，可能会导致线程阻塞。

适用场景

- 写入操作较多、冲突频繁的场景。

### 乐观锁

乐观锁认为线程安全问题不一定发生，因此不加锁，只在更新数据库时判断是否有其他线程对数据进行修改。常见的实现方式有版本号法和 CAS 操作。

优点

- 性能较高，因为不需要加锁。
- 并发度高，适合读取操作较多的场景。

缺点

- 需要处理冲突，如果发生冲突则需要重试或抛出异常。
- 可能在高并发情况下出现性能问题。

适用场景

- 读取操作较多、冲突较少的场景。

#### **悲观锁和乐观锁的比较**

- 悲观锁比乐观锁的**性能**低：悲观锁需要先加锁再操作，而乐观锁不需要加锁，所以乐观锁通常具有更好的性能。
- 悲观锁比乐观锁的**冲突处理能力**低：悲观锁在冲突发生时直接阻塞其他线程，乐观锁则是在提交阶段检查冲突并进行重试。
- 悲观锁比乐观锁的**并发度**低：悲观锁存在锁粒度较大的问题，可能会限制并发性能；而乐观锁可以实现较高的并发度。
- 应用场景：两者都是互斥锁，悲观锁适合写入操作较多、冲突频繁的场景；乐观锁适合读取操作较多、冲突较少的场景。



## 单体下一人多单超卖问题

### 乐观锁解决一人多单超卖问题

#### 实现方式一：版本号法

1. 为表新增一个版本号字段 `version`。
2. 线程 1 查询完库存，在进行库存扣减操作的同时将版本号 +1。
3. 线程 2 在查询库存时，同时查询出当前的版本号，发现库存充足，也准备执行库存扣减操作，但需要判断当前的版本号是否是之前查询时的版本号。
4. 如果版本号发生改变，说明数据库中的数据已经发生修改，需要重试或抛出异常。

#### 实现方式二：CAS 法

1. 线程 1 查询完库存后进行库存扣减操作。
2. 线程 2 在查询库存时，发现库存充足，也准备执行库存扣减操作，但需要判断当前的库存是否是之前查询时的库存。
3. 如果库存数量发生改变，说明数据库中的数据已经发生修改，需要重试或抛出异常。



## 单体下的一人一单超卖问题

在单体架构中，实现一人一单的秒杀功能时，可能会出现超卖问题。即使一个用户只能下一单，但由于线程并发问题，可能会导致同一个用户多次下单。

### 悲观锁

悲观锁通过加锁的方式，确保同一用户的下单操作是串行的，从而避免超卖问题。

#### 实现步骤

1. **锁的范围尽量小**：`synchronized` 尽量锁代码块，而不是方法，锁的范围越大性能越低。
2. **锁的对象一定要是一个不变的值**：我们不能直接锁 `Long` 类型的 `userId`，每请求一次都会创建一个新的 `userId` 对象。要使用 `toString()` 方法转成 `String` 类型的 `userId`，并使用 `intern()` 方法从常量池中寻找与当前字符串值一致的字符串对象，保障一个用户发送多次请求，每次请求的 `userId` 都是不变的，从而能够完成锁的效果。
3. **锁住整个事务**：而不是锁住事务内部的代码。如果我们锁住事务内部的代码，会导致其他线程能够进入事务，当我们事务还未提交，锁一旦释放，仍然会存在超卖问题。
4. **让代理对象生效**：Spring 的 `@Transactional` 注解要想事务生效，必须使用动态代理。Service 中一个方法中调用另一个方法，另一个方法使用了事务，此时会导致 `@Transactional` 失效，所以我们需要创建一个代理对象，使用代理对象来调用方法。
   - 引入 AOP 依赖，动态代理是 AOP 的常见实现之一。
   - 暴露动态代理对象，默认是关闭的。
   - 使用 `AopContext.currentProxy()` 获取代理对象。



# 分布式锁总结

## 定义
分布式锁是一种在分布式系统或集群模式下，能够实现多进程可见且互斥的锁机制。它解决了传统 `synchronized` 锁在集群环境下失效的问题，通过在整个系统全局设置一个锁监视器，确保不同节点的 JVM 都能识别，从而实现集群下只允许一个线程访问一个代码块。

## 特点
- **多线程可见**：所有节点上的线程都能看到锁的状态。
- **互斥**：保证在任何时刻只有一个节点能获得锁，其他节点需等待。
- **高可用**：具备容错性，即使在网络分区或节点故障时也能正常工作。若持有锁的节点故障或宕机，系统能自动释放该锁，确保其他节点可继续获取。
- **高性能**：具备良好性能，减少对共享资源的访问等待时间和锁竞争开销。
- **安全性**：
  - **可重入性**：已获得锁的节点可继续请求获取该锁而不会造成死锁。
  - **锁超时机制**：设置超时机制，避免节点因故障等原因无限期持有锁，影响系统正常运行。

## 常见实现方式

|        | MySQL                   | Redis                    | Zookeeper                      |
| ------ | ----------------------- | ------------------------ | ------------------------------ |
|        | 利用mysql本身的互锁机制 | 利用setnx这样的互斥命令  | 利用节点的唯一性和有序性实现互 |
| 高可用 | 好                      | 好                       | 好                             |
| 高性能 | 一般                    | 好                       | 一般                           |
| 安全性 | 断开连接，自动释放锁    | 利用锁超时时间，到期释放 | 临时节点，断开连接自动释放     |

- **基于关系数据库**：利用数据库事务特性和唯一索引实现，通过插入具有唯一约束的记录作为锁，其他进程受数据库并发控制机制限制。
- **基于缓存（如 Redis）**：使用分布式缓存服务提供的原子操作实现，将锁信息存储在缓存中，其他进程通过检查缓存中的锁状态判断是否可获取锁。
- **基于 ZooKeeper**：通过创建临时有序节点，每个请求尝试创建唯一节点并检查是否为最小节点，若是则获取到锁。
- **基于分布式算法**：如 Chubby、DLM 等，通过在分布式系统中协调进程间通信和状态变化实现。

## Redis 中的实现指令
- **获取锁**：
  
  - 方式一：
    ```
    setnx [key] [value]
    expire [key] [time]
    ```
  - 方式二（推荐，保障原子性）：
    ```
    set [key] [value] ex [time] nx
    ```
- **释放锁**：
  - 手动释放：
    ```
    del [key]
    ```
  - 超时自动释放：通过设置过期时间实现。





## 集群下的一人一单超卖问题

### 分布式锁解决超卖问题总结

在高并发场景下，如电商秒杀活动，可能会出现超卖问题。这是因为多个线程或进程同时获取资源，导致库存扣减错误。为解决此问题，引入分布式锁确保同一时刻只有一个线程能操作共享资源。

### 分布式锁实现

#### 锁的实现类
- 使用 Lua 脚本确保判断锁和释放锁的原子性，避免因线程阻塞等问题导致的超卖。

### Lua 脚本实现
- 比较缓存中的线程标识与当前线程标识是否一致，一致则删除锁，否则不操作。

#### 业务代码改造
- 在业务逻辑中使用分布式锁替代 `synchronized`，确保同一用户在同一时刻只能下一个订单。

#### 优化过程

### 优化一：添加线程标识

- 在锁中加入线程标识，释放锁时判断是否为当前线程的锁，避免误删其他线程的锁。
```java
String threadId = ID_PREFIX + Thread.currentThread().getId();
```

### 优化二：使用 Lua 脚本保障原子性
- 将判断锁和释放锁的操作放在 Lua 脚本中执行，确保原子性，防止因线程阻塞等问题导致的超卖。

## 优点
- **多线程可见**：锁信息存储在 Redis 中，所有 JVM 实例都能访问。
- **互斥**：`SET EX NX` 指令确保同一时刻只有一个线程获取锁。
- **高可用**：经过层层优化，即使在极端情况下也能防止超卖。
- **高性能**：Redis 的高 IO 速度和 Lua 脚本的快速执行保障性能。
- **安全性**：线程标识和 Lua 脚本充分保障线程安全，避免并发问题，超时释放机制防止死锁。

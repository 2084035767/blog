# 数据一致性问题

## 缓存的优点与问题

缓存的使用确实能显著降低后端负载，提高读写效率，减少响应时间。然而，缓存并非没有缺点。引入缓存会增加系统的维护成本，并且会带来数据一致性问题。因此，在项目中使用缓存时，需要经过前期的测试和预算，确保引入缓存后带来的价值超过其代价。

## 数据一致性问题的原因

数据一致性的根本原因是缓存和数据库中的数据不同步。为了解决这个问题，需要选择一个合适的缓存更新策略，使缓存和数据库中的数据尽可能即时同步。

## 常见的缓存更新策略

|          | 内存淘汰（全自动）                                           | 超时剔除（半自动）                                           | 主动更新（手动）                           |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
| 说明     | 利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存。 | 给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存。 | 编写业务逻辑，在修改数据库的同时，更新缓存 |
| 一致性   | 差                                                           | 一般                                                         | 好                                         |
| 维护成本 | 无                                                           | 低                                                           | 高                                         |



### 内存淘汰（全自动）

利用Redis的内存淘汰机制实现缓存更新。Redis的内存淘汰机制在内存不足时会根据一定的策略自动淘汰部分数据。常见的淘汰策略包括：

- **noeviction（默认）**：当达到内存限制并且客户端尝试执行写入操作时，Redis会返回错误信息，拒绝新数据的写入，保证数据完整性和一致性。
- **allkeys-lru**：从所有的键中选择最近最少使用（LRU）的数据进行淘汰。
- **allkeys-random**：从所有的键中随机选择数据进行淘汰。
- **volatile-lru**：从设置了过期时间的键中选择最近最少使用的数据进行淘汰。
- **volatile-random**：从设置了过期时间的键中随机选择数据进行淘汰。
- **volatile-ttl**：从设置了过期时间的键中选择剩余生存时间（TTL）最短的数据进行淘汰。

### 超时剔除（半自动）

手动给缓存数据添加TTL，到期后Redis自动删除缓存。

### 主动更新（手动）

手动编码实现缓存更新，在修改数据库的同时更新缓存。常见的主动更新策略包括：

#### 双写方案（Cache Aside Pattern）

1. **读取（Read）**：当需要读取数据时，首先检查缓存是否存在该数据。如果缓存中存在，直接返回缓存中的数据。如果缓存中不存在，则从底层数据存储（如数据库）中获取数据，并将数据存储到缓存中。
2. **写入（Write）**：当进行数据写入操作时，首先更新底层数据存储中的数据。然后，根据具体情况，可以选择直接更新缓存中的数据，或者是简单地将缓存中与修改数据相关的条目标记为无效状态（缓存失效）。

使用双写方案需要考虑以下几个问题：

- **更新缓存模式 vs 删除缓存模式**：更新缓存模式每次更新数据库都更新缓存，但无效写操作较多。删除缓存模式更新数据时更新数据库并删除缓存，查询时更新缓存，无效写操作较少。
- **操作顺序**：先操作缓存还是先操作数据库？推荐先操作数据库，再删除缓存，以减少缓存击穿问题的概率。
- **原子性保证**：对于单体系统，可以将缓存与数据库操作放在同一个事务中。对于分布式系统，可以利用TCC（Try-Confirm-Cancel）等分布式事务方案。

#### 读写穿透方案（Read/Write Through Pattern）

1. **读取穿透（Read Through）**：当进行读取请求时，首先检查缓存。如果所请求的数据在缓存中找到，直接返回数据。如果缓存中没有找到数据，则将请求转发给数据存储以获取数据。获取到的数据随后存储在缓存中。
2. **写入穿透（Write Through）**：当进行写入请求时，首先将数据写入缓存。缓存立即将写操作传播到数据存储，确保缓存和数据存储之间的数据保持一致。

#### 写回方案（Write Behind Caching Pattern）

1. **读取（Read）**：先检查缓存中是否存在数据，如果不存在，则从底层数据存储中获取数据，并将数据存储到缓存中。
2. **写入（Write）**：先更新底层数据存储，然后将待写入的数据放入一个缓存队列中。在适当的时机，通过批量操作或异步处理，将缓存队列中的数据写入底层数据存储。

### 主动更新策略的比较

- **双写方案** 和 **读写穿透方案** 在写入数据时都会直接更新缓存，以保持缓存和底层数据存储的一致性。而 **写回方案** 延迟了缓存的更新操作，将数据先放入缓存队列，然后再进行批量或异步写入。
- **读写穿透方案** 和 **写回方案** 相比，**写回方案** 具有更高的写入性能，因为它通过批量和异步操作减少了频繁的写入操作。但是 **写回方案** 带来了数据一致性的考虑，需要确保缓存和底层数据存储在某个时间点上保持一致，而 **读写穿透方案** 将数据库和缓存整合为一个服务，由服务来维护缓存与数据库的一致性，调用者无需关心数据一致性问题，降低了系统的可维护性，但是实现困难。

### 主动更新策略的应用场景

- **双写方案** 较适用于读多写少的场景，数据的一致性由应用程序主动管理。
- **读写穿透方案** 适用于数据实时性要求较高、对一致性要求严格的场景。
- **写回方案** 适用于追求写入性能的场景，对数据的实时性要求相对较低、可靠性也相对低。

